



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
        <meta name="author" content="jackeyt">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.4.0">
    
    
      
        <title>驱动第三天 - jackeyt wiki</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.0284f74d.css">
      
      
    
    
      <script src="../assets/javascripts/modernizr.74668098.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#-" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="jackeyt wiki" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              jackeyt wiki
            </span>
            <span class="md-header-nav__topic">
              
                驱动第三天
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href=".." title="jackeyt wiki" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    jackeyt wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="介绍" class="md-nav__link">
      介绍
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      ARM_Linux驱动入门
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        ARM_Linux驱动入门
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../驱动第一天---驱动基础/" title="驱动第一天" class="md-nav__link">
      驱动第一天
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../驱动第二天---中断/" title="驱动第二天" class="md-nav__link">
      驱动第二天
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        驱动第三天
      </label>
    
    <a href="./" title="驱动第三天" class="md-nav__link md-nav__link--active">
      驱动第三天
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" title="1. 总线的基本概念" class="md-nav__link">
    1. 总线的基本概念
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-sysfs" title="2. Sysfs文件系统" class="md-nav__link">
    2. Sysfs文件系统
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" title="3. 写一个自己的总线驱动" class="md-nav__link">
    3. 写一个自己的总线驱动
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-bus" title="3.1 写一个自己的总线驱动——bus" class="md-nav__link">
    3.1 写一个自己的总线驱动——bus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-driver" title="3.2 写一个自己的总线驱动——driver" class="md-nav__link">
    3.2 写一个自己的总线驱动——driver
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-device" title="3.3 写一个自己的总线驱动——device" class="md-nav__link">
    3.3 写一个自己的总线驱动——device
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34" title="3.4 如何实现总线的匹配" class="md-nav__link">
    3.4 如何实现总线的匹配
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-platform" title="4. 平台总线(platform)的基本概念" class="md-nav__link">
    4. 平台总线(platform)的基本概念
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" title="为什么会有平台总线：" class="md-nav__link">
    为什么会有平台总线：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-platform" title="5. 平台总线(platform)编程接口" class="md-nav__link">
    5. 平台总线(platform)编程接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-platform-led" title="5. 写一个platform led驱动" class="md-nav__link">
    5. 写一个platform led驱动
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../三种总线的横向对比表/" title="总线的横向对比表" class="md-nav__link">
      总线的横向对比表
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../ARMLinux设备树/" title="驱动第四天" class="md-nav__link">
      驱动第四天
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../手把手教你从单片机移植驱动到ARMLinux上/" title="驱动第五天" class="md-nav__link">
      驱动第五天
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      ARM_Linux应用开发
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        ARM_Linux应用开发
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../VSCode搭建ARMLinuxMakefile工程IDE/" title="0.IDE环境搭建" class="md-nav__link">
      0.IDE环境搭建
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      栗子派LeeZ—RK3399试玩
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        栗子派LeeZ—RK3399试玩
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../LeezPi-RK3399_开箱/" title="0.开箱" class="md-nav__link">
      0.开箱
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../LeezPi-RK3399_SDK使用/" title="1.SDK使用说明" class="md-nav__link">
      1.SDK使用说明
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../LeezPi-RK3399_Android9编译说明/" title="2.Android9编译说明" class="md-nav__link">
      2.Android9编译说明
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" title="1. 总线的基本概念" class="md-nav__link">
    1. 总线的基本概念
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2-sysfs" title="2. Sysfs文件系统" class="md-nav__link">
    2. Sysfs文件系统
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3" title="3. 写一个自己的总线驱动" class="md-nav__link">
    3. 写一个自己的总线驱动
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-bus" title="3.1 写一个自己的总线驱动——bus" class="md-nav__link">
    3.1 写一个自己的总线驱动——bus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-driver" title="3.2 写一个自己的总线驱动——driver" class="md-nav__link">
    3.2 写一个自己的总线驱动——driver
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-device" title="3.3 写一个自己的总线驱动——device" class="md-nav__link">
    3.3 写一个自己的总线驱动——device
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34" title="3.4 如何实现总线的匹配" class="md-nav__link">
    3.4 如何实现总线的匹配
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4-platform" title="4. 平台总线(platform)的基本概念" class="md-nav__link">
    4. 平台总线(platform)的基本概念
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_1" title="为什么会有平台总线：" class="md-nav__link">
    为什么会有平台总线：
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-platform" title="5. 平台总线(platform)编程接口" class="md-nav__link">
    5. 平台总线(platform)编程接口
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#5-platform-led" title="5. 写一个platform led驱动" class="md-nav__link">
    5. 写一个platform led驱动
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="-">驱动第三天---总线</h1>
<div class="toc">
<ul>
<li><a href="#-">驱动第三天---总线</a><ul>
<li><a href="#1">1. 总线的基本概念</a></li>
<li><a href="#2-sysfs">2. Sysfs文件系统</a></li>
<li><a href="#3">3. 写一个自己的总线驱动</a><ul>
<li><a href="#31-bus">3.1 写一个自己的总线驱动——bus</a></li>
<li><a href="#32-driver">3.2 写一个自己的总线驱动——driver</a></li>
<li><a href="#33-device">3.3 写一个自己的总线驱动——device</a></li>
<li><a href="#34">3.4 如何实现总线的匹配</a></li>
</ul>
</li>
<li><a href="#4-platform">4. 平台总线(platform)的基本概念</a><ul>
<li><a href="#_1">为什么会有平台总线：</a></li>
</ul>
</li>
<li><a href="#5-platform">5. 平台总线(platform)编程接口</a></li>
<li><a href="#5-platform-led">5. 写一个platform led驱动</a></li>
</ul>
</li>
<li><a href="#iic">IIC总线驱动</a><ul>
<li><a href="#1-i2c">1 i2c协议和时序</a></li>
<li><a href="#2-i2c">2 i2c子系统软件框架 ##</a></li>
<li><a href="#3-i2c">3  I2c子系统中涉及到的设备树文件：</a></li>
<li><a href="#4-i2c-driver">4  i2c driver驱动的编写</a><ul>
<li><a href="#i2c-driver-i2cprobe6thiic_drv">编写一个最简单的i2c driver驱动，最终可实现调用 i2c的probe，代码可参考（6th/iic_drv）</a></li>
</ul>
</li>
<li><a href="#4">4 陀螺仪和加速度工作原理，它们的应用</a></li>
<li><a href="#41">4.1  硬件接线图</a></li>
<li><a href="#42">4.2  陀螺仪和加速度工作原理及应用</a><ul>
<li><a href="#421">4.2.1  陀螺仪</a></li>
</ul>
</li>
<li><a href="#5-mpu605">5 mpu605   常用寄存器</a></li>
<li><a href="#6-iicapis">6 iic驱动发送指令APIs</a></li>
<li><a href="#7-ioctl">7 ioctl:　给驱动发送不同指令</a></li>
<li><a href="#8-mpu6050">8 mpu6050的数据</a></li>
</ul>
</li>
</ul>
</div>
<hr />
<hr />
<h2 id="1">1. 总线的基本概念</h2>
<p>1.1 Linux设备驱动模型的由来</p>
<ol>
<li>实现入口函数<code>xxx_init()</code>和卸载函数<code>xxx_exit()</code></li>
<li>申请设备号 <code>register_chrdev</code> (与内核相关)</li>
<li>利用udev/mdev机制创建设备文件(节点) <code>class_create, device_create</code> (与内核相关)</li>
<li>
<p>硬件部分初始化</p>
<blockquote>
<p>io资源映射 ioremap,内核提供gpio库函数 (与硬件相关)</p>
<p>注册中断(与硬件相关) <br />
5. 构建 file_operation结构 (与内核相关)
6. 实现操作硬件方法  xxx_open,xxx_read,xxxx_write</p>
</blockquote>
</li>
</ol>
<p><img alt="" src="../images/驱动驱动模型.png" /></p>
<h2 id="2-sysfs">2. Sysfs文件系统</h2>
<p>:<img alt="" src="../images/sysfs文件系统.png" />
:<img alt="" src="images/sys目录.png" /></p>
<pre><code>block：用于管理块设备，系统中的每一个块设备会在该目录下对应一个子目录。
bus：用于管理总线，每注册一条总线，在该目录下有一个对应的子目录。
其中，每个总线子目录下会有两个子目录：devices和drivers。
devices包含系统中所有属于该总线的的设备。
class：将系统中的设备按功能分类。
dev：该目录包含已注册的设备号（设备节点)的视图，包括char和block
kernel：内核中的相关参数。
module：内核中的模块信息。
fireware：内核中的固件信息。
fs：描述内核中的文件系统。
</code></pre>
<h2 id="3">3. 写一个自己的总线驱动</h2>
<p>写一个自己的总线模型，实现如下图的功能：</p>
<p><img alt="" src="../images/总线模型编程.png" /></p>
<h3 id="31-bus">3.1 写一个自己的总线驱动——bus</h3>
<ol>
<li>
<p>数据类型</p>
<p>struct bus_type {</p>
<p>const char      *name;  //假如name =xxx cat /sys/bus/XXX</p>
<p>int (<em>match)(struct device </em>dev, struct device_driver *drv);</p>
<p>........</p>
<p>}</p>
</li>
<li>
<p>API
2.1 创建</p>
<p>int  bus_register(struct bus_type *bus);</p>
</li>
</ol>
<p>2.2 注销</p>
<pre><code>void bus_unregister(struct bus_type *bus);
</code></pre>
<h3 id="32-driver">3.2 写一个自己的总线驱动——driver</h3>
<ol>
<li>数据类型<pre><code>struct device_driver {
const char      *name;
struct bus_type     *bus;

int (*probe) (struct device *dev);
int (*remove) (struct device *dev);

};
</code></pre>
</li>
</ol>
<h3 id="33-device">3.3 写一个自己的总线驱动——device</h3>
<ol>
<li>数据类型<pre><code>struct device{

struct kobject kobj;//代表一切对象的父类，那么，在这里引了kobject，说明device是继承kobject,
const char      *init_name; /* device 的名字 */

struct bus_type *bus;       /* 需要挂接上的bus总线 mybus */
struct device_driver *driver;   /* 与之（内核做的）已经匹配成功的drv */
void        *platform_data; /* 万能型 指针 指向dev的自定义的某些数据，或者说用于drv与dev传递数据的一个载体*/
}
</code></pre>
</li>
</ol>
<p>2 APIs</p>
<p>2.1 创建</p>
<pre><code>int device_register(struct device *dev)
</code></pre>
<p>2.2 注销</p>
<pre><code>void device_unregister(struct device *dev)
</code></pre>
<h3 id="34">3.4 如何实现总线的匹配</h3>
<p>如何实现总线匹配，匹配成功之后会自动调用driver的probe方法：</p>
<blockquote>
<p>1， 实现bus对象中 match方法 </p>
<p>2， 保证driver和device中名字要一样</p>
<pre><code>//如果返回值 为1 代表匹配成功，否则不成功
int mybus_match(struct device *dev, struct device_driver *drv)
{
</code></pre>
</blockquote>
<pre><code>    printk("-------------%s------------\n",__FUNCTION__);

    if( strncmp(dev-&gt;kobj.name ,    drv-&gt;name ,  sizeof(drv-&gt;name))  ==  0   )
    {
        printk("match ok\n");
        return 1;
    }
    else 
    {
        printk("match error\n");
        return 0;
    }
}
</code></pre>
<h2 id="4-platform">4. 平台总线(platform)的基本概念</h2>
<p><img alt="" src="../images/平台总线模型.png" /></p>
<p>平台总线模型：</p>
<h5 id="_1">为什么会有平台总线：</h5>
<p>1 从厂商的角度出发</p>
<pre><code>用于平台升级：三星：　2410, 2440, 6410, s5pc100  s5pv210  4412
    硬件平台升级的时候，部分的模块的控制方式，基本上是类似的
    但是模块的地址是不一样

    gpio控制逻辑： 1， 配置gpio的输入输出功能： gpxxconf
                  2， 给gpio的数据寄存器设置高低电平： gpxxdata
                      逻辑操作基本上是一样的
                      但是地址不一样

    uart控制：1,设置8n1,115200, no AFC
                UCON,ULCON, UMODOEN, UDIV

                "逻辑基本上是一样的,但是地址不一样"

问题：
当soc升级的时候， 对于相似的设备驱动，需要编写很多次(如果不用平台总线)
但是会有大部分重复代码

解决：引入平台总线   
    device(中断/地址)和driver(操作逻辑) 分离
    在升级的时候，只需要修改device中信息即可(中断/地址)
    实现一个driver代码能够驱动多个平台相似的模块，并且修改的代码量很少
</code></pre>
<p>2 从使用者的角度出发</p>
<h2 id="5-platform">5. 平台总线(platform)编程接口</h2>
<p>平台总线中的三元素：</p>
<p>1， bus：邮bus衍生出来的platform_bus:不需要自己创建，开机的时候自动创建</p>
<pre><code>    struct bus_type platform_bus_type = {
        .name       = "platform",
        .dev_groups = platform_dev_groups,
        .match      = platform_match,
        .uevent     = platform_uevent,
        .pm     = &amp;platform_dev_pm_ops,
    };

匹配方法：

static int platform_match(struct device *dev, struct device_driver *drv)
{
    struct platform_device *pdev = to_platform_device(dev);
    struct platform_driver *pdrv = to_platform_driver(drv);

    /* Attempt an OF style match first */
    if (of_driver_match_device(dev, drv))
        return 1;

    /* Then try ACPI style match */
    if (acpi_driver_match_device(dev, drv))
        return 1;

    /* Then try to match against the id table */
    if (pdrv-&gt;id_table)
        return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;

    /* fall-back to driver name match */
    return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);
}

    。。。。。。dts   acpi
    1，优先匹配pdriver中的id_table,里面包含了支持不同的平台的名字
    2，直接匹配driver中名字和device中名字
</code></pre>
<p>2，device对象：</p>
<pre><code>struct platform_device {
    const char  *name;  //用于做匹配
    int     id;  // 一般都是直接给-1
    struct device   dev; // 继承了device父类
    u32     num_resources; // 资源的个数
    struct resource *resource; // 资源：包括了一个设备的地址和中断
}
</code></pre>
<p>资源对象resource:</p>
<pre><code>struct resource {
resource_size_t start;
resource_size_t end;
const char *name;
unsigned long flags;
struct resource *parent, *sibling, *child;
};
</code></pre>
<p>注册和注销</p>
<pre><code>    int  platform_device_register(struct platform_device * pdev)；
    void  platform_device_unregister(struct platform_device * pdev)
</code></pre>
<p>3，driver对象</p>
<pre><code>struct platform_driver {
        int (*probe)(struct platform_device *); //匹配成功之后被调用的函数
        int (*remove)(struct platform_device *);//device移除的时候调用的函数
        struct device_driver driver; //继承了driver父类
                            |
                            const char      *name;
        const struct platform_device_id *id_table; //如果driver支持多个平台，在列表中写出来
}
注册和注销
    int platform_driver_register(struct platform_driver *drv);
    void platform_driver_unregister(struct platform_driver *drv)
</code></pre>
<p>4， drv如何去获取dev中的数据</p>
<blockquote>
<p>获取资源数据</p>
<pre><code>int platform_get_irq(struct platform_device * dev,unsigned int num)                                     
struct resource * platform_get_resource_byname(struct platform_device * dev,
                    unsigned int type,const char * name)
</code></pre>
</blockquote>
<h2 id="5-platform-led">5. 写一个platform led驱动</h2>
<p>编写代码：　编写一个能在多个平台下使用的led驱动</p>
<p>1，注册一个platform_device,定义资源：地址和中断</p>
<pre><code>struct resource {
    resource_size_t start; // 开始
    resource_size_t end; //结束
    const char *name; //描述，自定义
    unsigned long flags; //区分当前资源描述的是中断(IORESOURCE_IRQ)还是内存（IORESOURCE_MEM）
        #define IORESOURCE_MEM      0x00000200
        #define IORESOURCE_REG      0x00000300  /* Register offsets */
        #define IORESOURCE_IRQ      0x00000400
    struct resource *parent, *sibling, *child;
};
</code></pre>
<p>2，注册一个platform_driver，实现操作设备的代码</p>
<pre><code>注册完毕，同时如果和pdev匹配成功，自动调用probe方法：
        probe方法： 对硬件进行操作
                a，注册设备号，并且注册fops--为用户提供一个设备标示，同时提供文件操作io接口
                b， 创建设备节点
                c， 初始化硬件
                            ioremap(地址);  //地址从pdev需要获取
                            readl/writle();
                d，实现各种io接口： xxx_open, xxx_read, ..
        获取资源的方式：        
        //获取资源
        // 参数1: 从哪个pdev中获取资源
        // 参数2:  资源类型
        // 参数3: 表示获取同种资源的第几个
            struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num)
</code></pre>
<p>3，platform 获取中断（irq）资源
/<em><em>
 * platform_get_irq - get an IRQ for a device
 * @dev: platform device
 * @num: IRQ number index
 </em>/
int platform_get_irq(struct platform_device </em>dev, unsigned int num)</p>
<p>4 ，platform id_table的定义：</p>
<pre><code>struct platform_device_id {
    char name[PLATFORM_NAME_SIZE];
    kernel_ulong_t driver_data;
};
</code></pre>
<h1 id="iic">IIC总线驱动</h1>
<p>主要内容：</p>
<ol>
<li>i2c协议和时序</li>
<li>i2c子系统软件框架</li>
<li>i2c从设备驱动编写方式--不考虑具体的硬件</li>
<li>mpu6050硬件连接，陀螺仪和加速度工作原理，它们的应用</li>
<li>mpu6050数据和获取</li>
<li>mpu6050从设备驱动编写</li>
</ol>
<h2 id="1-i2c">1 i2c协议和时序</h2>
<p>IIC通讯波形图:
<img alt="" src="../images/iic协议波形.png" /></p>
<p>IIC协议:
<img alt="" src="../images/IIC读写操作.png" /></p>
<h2 id="2-i2c">2 i2c子系统软件框架 ##</h2>
<pre><code>应用
------------------------------------------
i2c driver:从设备驱动层
     需要和应用层进行交互
     封包数据，不知道数据是如何写入到硬件

------------------------------------------
i2c 核心层：维护i2c 总线，包括i2c driver, i2c client链表
drivers/i2c/i2c-core.c
---------------------------------------------------
i2c adapter层：i2c控制层，初始化i2c控制器
        完成将数据写入或读取-从设备硬件
        不知道数据具体是什么，但是知道如何操作从设备
drivers/i2c/busses/i2c-s3c2410.c
================================================================
</code></pre>
<p>去内核确定：i2c硬件驱动代码是否加入内核一起编译</p>
<pre><code>make menuconfig
    Device Drivers  ---&gt;
        -*- I2C support  ---&gt; //编译i2c-core.c
            I2C Hardware Bus support  ---&gt;
                &lt;*&gt; S3C2410 I2C Driver // i2c-s3c2410.c
</code></pre>
<h2 id="3-i2c">3  I2c子系统中涉及到的设备树文件：</h2>
<blockquote>
<p>查看原理图：MPU6050挂载至 I2C_5</p>
<p>查看6050datasheet：如果AD0是高电平的话，那么，mpu6050的地址就是0x69,否则AD0为低时候，就是0x68</p>
</blockquote>
<p>设备树：</p>
<p>控制器对应的设备树：arch/arm/boot/dts/exynos4.dtsi</p>
<pre><code>      i2c_0: i2c@13860000 {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            compatible = "samsung,s3c2440-i2c";
            reg = &lt;0x13860000 0x100&gt;;
            interrupts = &lt;0 58 0&gt;;
            clocks = &lt;&amp;clock 317&gt;;
            clock-names = "i2c";
            pinctrl-names = "default";
            pinctrl-0 = &lt;&amp;i2c0_bus&gt;;
            status = "disabled";
    };

    i2c_5: i2c@138B0000 {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            compatible = "samsung,s3c2440-i2c";
            reg = &lt;0x138B0000 0x100&gt;;
            interrupts = &lt;0 63 0&gt;;
            clocks = &lt;&amp;clock 322&gt;;
            clock-names = "i2c";
            status = "disabled";
    };
</code></pre>
<p>我们用的：   arch/arm/boot/dts/exynos4412-fs4412.dts</p>
<pre><code>    i2c@13860000 {
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            samsung,i2c-sda-delay = &lt;100&gt;;
            samsung,i2c-max-bus-freq = &lt;20000&gt;;
            pinctrl-0 = &lt;&amp;i2c0_bus&gt;;
            pinctrl-names = "default";
            status = "okay";
            s5m8767_pmic@66 {
                    compatible = "samsung,s5m8767-pmic";
                    reg = &lt;0x66&gt;;
                    ...........
                    };
            };
</code></pre>
<p>我们自己做一个设备树节点，来描述mpu6050的信息：</p>
<pre><code>i2c控制器地址0-8组 共9组设备
    0x1386_0000, //0
    0x1387_0000,
    0x1388_0000, 
    0x1389_0000,
    0x138A_0000,
    0x138B_0000, ------ MPU6050
    0x138C_0000, 
    0x138D_0000, 
    0x138E_0000,//8
</code></pre>
<p>i2C_5的设备树节点：</p>
<pre><code>i2c@138B0000{
            #address-cells = &lt;1&gt;;
            #size-cells = &lt;0&gt;;
            samsung,i2c-sda-delay = &lt;100&gt;;
            samsung,i2c-max-bus-freq = &lt;20000&gt;;
            pinctrl-0 = &lt;&amp;i2c5_bus&gt;;
            pinctrl-names = "default";
            status = "okay";

            mpu6050@68 {
                    compatible = "InvenSense,mpu6050";
                    reg = &lt;0x68&gt;;
                    };

    };
</code></pre>
<p>编译设备树源码：</p>
<pre><code>make dtbs
</code></pre>
<p>烧写：。。。。。。。</p>
<h2 id="4-i2c-driver">4  i2c driver驱动的编写</h2>
<blockquote>
<p>a， 添加i2c client的信息，必须包含在控制器对应的节点中</p>
<p>b，直接编写i2c driver</p>
<p>1，构建i2c driver，并注册到i2c总线</p>
<p>2，实现probe：
      |
      申请设备号，实现fops
      创建设备文件
      通过i2c的接口去初始化i2c从设备</p>
</blockquote>
<p>几个常用的对象：</p>
<pre><code>struct i2c_driver {//表示是一个从设备的驱动对象
    int (*probe)(struct i2c_client *, const struct i2c_device_id *);
    int (*remove)(struct i2c_client *);
    struct device_driver driver; //继承了父类
                |
                const struct of_device_id   *of_match_table;
    const struct i2c_device_id *id_table;//用于做比对，非设备树的情况
}
注册和注销
    int i2c_add_driver( struct i2c_driver *driver);
    void i2c_del_driver(struct i2c_driver *);


struct i2c_client {//描述一个从设备的信息,不需要在代码中创建，因为是由i2c adapter帮我们创建
    unsigned short addr;        //从设备地址，来自于设备树中&lt;reg&gt;
    char name[I2C_NAME_SIZE]; //用于和i2c driver进行匹配，来自于设备树中compatible
    struct i2c_adapter *adapter;//指向当前从设备所存在的i2c adapter
    struct device dev;      // 继承了父类
};
创建i2c client的函数
struct i2c_client *i2c_new_device(struct i2c_adapter *adap, struct i2c_board_info const *info)



struct i2c_adapter {//描述一个i2c控制器，也不是我们要构建，原厂的代码会帮我们构建
    const struct i2c_algorithm *algo; //算法
                |
                int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,int num);

    struct device dev; //继承了父类，也会被加入到i2c bus
    int nr; //编号

}
注册和注销：
int i2c_add_adapter(struct i2c_adapter * adapter);
void i2c_del_adapter(struct i2c_adapter * adap);
</code></pre>
<h4 id="i2c-driver-i2cprobe6thiic_drv">编写一个最简单的i2c driver驱动，最终可实现调用 i2c的probe，代码可参考（6th/iic_drv）</h4>
<h2 id="4">4 陀螺仪和加速度工作原理，它们的应用</h2>
<h2 id="41">4.1  硬件接线图</h2>
<blockquote>
<p>查看原理图：MPU6050挂载至 I2C_5</p>
<p>查看6050datasheet：如果AD0是高电平的话，那么，mpu6050的地址就是0x69,否则AD0为低时候，就是0x68</p>
</blockquote>
<h2 id="42">4.2  陀螺仪和加速度工作原理及应用</h2>
<h3 id="421">4.2.1  陀螺仪</h3>
<p>陀螺仪的模型：</p>
<p><img alt="" src="../images/陀螺仪基本结构.png" /></p>
<p>原理：</p>
<blockquote>
<p>小时候玩过陀螺，如果给它一定的旋转速度，陀螺会竖立旋转起来而不会倒</p>
<p>主要因为高速旋转有抗拒方向改变的趋向</p>
<p>陀螺仪就是内部的转子高速旋转，形成一个固定的初始化的参考平面</p>
<p>这样就可以通过测量初始的参考平面偏差计算出物体的旋转情况</p>
<p>陀螺仪的强项在于测量设备自身的旋转运动</p>
</blockquote>
<p>陀螺仪的产生：</p>
<pre><code>1850年法国的物理学家福柯(J.Foucault)为了研究地球自转，首先发现高速转动中的转子(rotor)，
由于惯性作用它的旋转轴永远指向一固定方向，他用希腊字gyro(旋转)和skopein(看)
两字合为gyro scopei一字来命名这种仪表
</code></pre>
<p>陀螺仪的基本部件：</p>
<pre><code>(1) 陀螺转子，转子装在一支架内
(2)内、外环，它是使陀螺自转轴获得所需角转动自由度的结构
    内环可环绕平面两轴作自由运动
    在内环架外加上一外环架，可以环绕平面做三轴作自由运动
(3) 附件(是指力矩马达、信号传感器等)。
</code></pre>
<p>陀螺仪的数据获取：       </p>
<pre><code>XYZ分别代表设备围绕XYZ三个轴旋转的角速度，陀螺仪可以捕捉很微小的运动轨迹变化，
因此可以做高分辨率和快速反应的旋转检测，但不能测量当前的运行方向
</code></pre>
<p>应用：</p>
<pre><code>1，陀螺仪用于飞行体运动的自动控制系统中，作为水平、垂直、俯仰、航向和角速度传感器
2，手机上的摄像头配合使用，比如防抖
3，各类手机游戏的传感器，包括一些第一视角类射击游戏，陀螺仪完整监测游戏者手的位移
   手机中的陀螺仪最早被iphone4应用，所以被大家所熟知
4，导航，手机配合GPS，导航能力已经可以达到专用的gps导航仪
</code></pre>
<p>加速度传感器：</p>
<p>重力加速度传感器的模型：</p>
<p><img alt="" src="../images/重力传感器原理.png" /></p>
<p>原理：</p>
<pre><code>重力施加在物体上,使它产生一个加速度，重力大小和此物体的质量成正比
物体在不同的运行中，会产生不同的重力，从而可以测量出物体的运动情况
</code></pre>
<p>重力加速度的数据获取：</p>
<pre><code>加速度测量传感器有x、y、z三轴，注意在手机上屏幕的坐标，以左上角作为原点的，而且Y向下。
注意区分这两个不同的坐标系。
加速传感器的单位是加速度m/s2。如果手机平放好，x，y在位置为0，
而z轴方向加速度=当前z方向加速度-g。由于g（重力加速度）垂直向下，
则g=-9.81m/s2，即z轴 a=0-(-9.81)=9.81m/s2
</code></pre>
<p>应用：</p>
<pre><code>1，图像自动翻转
2，游戏控制
3，计步器功能
</code></pre>
<h2 id="5-mpu605">5 mpu605   常用寄存器</h2>
<pre><code>#define SMPLRT_DIV      0x19 //采样频率寄存器-25 典型值：0x07(125Hz)
                                    //寄存器集合里的数据根据采样频率更新
#define CONFIG          0x1A    //配置寄存器-26-典型值：0x06(5Hz)
                                        //DLPF is disabled（DLPF_CFG=0 or 7）
#define GYRO_CONFIG     0x1B//陀螺仪配置-27,可以配置自检和满量程范围
                                    //典型值：0x18(不自检，2000deg/s)
#define ACCEL_CONFIG        0x1C    //加速度配置-28 可以配置自检和满量程范围及高通滤波频率
                                        //典型值：0x01(不自检，2G，5Hz)
#define ACCEL_XOUT_H    0x3B //59-65,加速度计测量值 XOUT_H
#define ACCEL_XOUT_L    0x3C  // XOUT_L
#define ACCEL_YOUT_H    0x3D  //YOUT_H
#define ACCEL_YOUT_L    0x3E  //YOUT_L
#define ACCEL_ZOUT_H    0x3F  //ZOUT_H
#define ACCEL_ZOUT_L    0x40 //ZOUT_L---64
#define TEMP_OUT_H      0x41 //温度测量值--65
#define TEMP_OUT_L      0x42
#define GYRO_XOUT_H     0x43 //陀螺仪值--67，采样频率（由寄存器 25 定义）写入到这些寄存器
#define GYRO_XOUT_L     0x44
#define GYRO_YOUT_H     0x45
#define GYRO_YOUT_L     0x46
#define GYRO_ZOUT_H     0x47
#define GYRO_ZOUT_L     0x48 //陀螺仪值--72
#define PWR_MGMT_1      0x6B //电源管理 典型值：0x00(正常启用)
</code></pre>
<h2 id="6-iicapis">6 iic驱动发送指令APIs</h2>
<pre><code>//发送iic数据的API
i2c_master_send(const struct i2c_client * client, const char * buf, int count)
//接收
i2c_master_recv(const struct i2c_client * client, char * buf, int count)

传送iic消息的最小单位为struct i2c_msg msg;

struct i2c_msg {//描述一个从设备要发送的数据的数据包
    __u16 addr;  //从设备地址，发送给那个从设备
    __u16 flags; //读1还是写0
    __u16 len;  //收发数据的长度
    __u8 *buf;  //指向收发数据的指针
};
</code></pre>
<p>以上两个函数都调用了：</p>
<pre><code>int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
</code></pre>
<h2 id="7-ioctl">7 ioctl:　给驱动发送不同指令</h2>
<pre><code>应用程序：
    ioctl(fd, cmd, args);
========================================
驱动中：xxx_ioctl()
{
        switch(cmd){

        }
}

如何定义命令：
    1， 直接定义一个数字
        #define IOC_GET_ACCEL  0x9999
    2, 通过系统的接口
        _IO(x,y)
        _IOR(x,y,z)
        _IOW(x,y,z)

        参数1：表示magic，字符
        参数2：区分不同命令，整数　
        参数３：传给驱动数据类型
</code></pre>
<p>mpu605——ioctl的用法举例：</p>
<pre><code>#define IOC_GET_ACCEL  _IOR('M', 0x34,union mpu6050_data)
#define IOC_GET_GYRO  _IOR('M', 0x35,union mpu6050_data)
#define IOC_GET_TEMP  _IOR('M', 0x36,union mpu6050_data)
</code></pre>
<h2 id="8-mpu6050">8 mpu6050的数据</h2>
<pre><code>    陀螺仪可测范围为 欧拉角格式±250，±500，±1000，±2000°/秒（dps） ，加速度计可测范围为±2，±4，±8，±16g
    加速度读取的值为：
    AFS_SEL      Full scale rang                  LSB  Sensitivy
        0               +-2g -----------------------16384 LSB/g
        1               +-4g -----------------------8192 LSB/g
        2               +-8g -----------------------4096 LSB/g
        3               +-16g------------------------2048 LSB/g

    温度值：
            C = (TEMP_OUT Register Value )/340 + 36.53

    陀螺仪值：
        FS_SEL      Full scale rang                  LSB  Sensitivy
        0               +-250 度/s ------------------131 LSB 度/s
        1               +-500 度/s ------------------65.5 LSB 度/s
        2               +-1000 度/s -----------------32.8 LSB 度/s
        3               +-2000 度/s ------------------16.4 LSB 度/s
</code></pre>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../驱动第二天---中断/" title="驱动第二天" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                驱动第二天
              </span>
            </div>
          </a>
        
        
          <a href="../三种总线的横向对比表/" title="总线的横向对比表" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                总线的横向对比表
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.245445c6.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>